#!/bin/bash
# Title: appimgman
# Description: Downloads AppImages and moves them to /usr/local/bin/.  Can also upgrade and remove installed AppImages.
# Dependencies: GNU coreutils, wget
# Author: simonizor
# Website: http://www.simonizor.gq
# License: GPL v2.0 only

X="0.2.5"
# Set appimgman version

REALPATH="$(readlink -f $0)"
RUNNING_DIR="$(dirname "$REALPATH")" # Find directory script is running from
if [ -f $RUNNING_DIR/functions.sh ]; then
    FUNCTIONS_VER="$(cat "$RUNNING_DIR"/functions.sh | sed -n 9p | cut -f2 -d'"')"
    if [ "$X" != "$FUNCTIONS_VER" ]; then
        echo "functions.sh $FUNCTIONS_VER version does not match $X; removing and updating..."
        rm "$RUNNING_DIR"/functions.sh || { echo "rm $RUNNING_DIR/functions.sh failed; trying with sudo..."; sudo rm "$RUNNING_DIR"/functions.sh; }
        echo "$RUNNING_DIR/functions.sh has been removed."
        echo "Downloading functions.sh from appimgman github repo..."
        wget --quiet --show-progress "https://github.com/simoniz0r/appimgman/raw/master/functions.sh" -O ~/.config/appimgman/cache/functions.sh
        chmod +x ~/.config/appimgman/cache/functions.sh
        mv ~/.config/appimgman/cache/functions.sh "$RUNNING_DIR"/functions.sh || { echo "mv to $RUNNING_DIR failed; trying as sudo..."; sudo mv ~/.config/appimgman/cache/functions.sh "$RUNNING_DIR"/functions.sh; }
        echo "functions.sh saved to $RUNNING_DIR/functions.sh"
        echo "appimgman will now exit."
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
    fi
    source "$RUNNING_DIR"/functions.sh # import functions from functions.sh
else
    echo "Missing required file $RUNNING_DIR/functions.sh !"
    echo "Downloading functions.sh from appimgman github repo..."
    wget --quiet --show-progress "https://github.com/simoniz0r/appimgman/raw/master/functions.sh" -O ~/.config/appimgman/cache/functions.sh
    chmod +x ~/.config/appimgman/cache/functions.sh
    mv ~/.config/appimgman/cache/functions.sh "$RUNNING_DIR"/functions.sh || { echo "mv to $RUNNING_DIR failed; trying as sudo..."; sudo mv ~/.config/appimgman/cache/functions.sh "$RUNNING_DIR"/functions.sh; }
    echo "functions.sh saved to $RUNNING_DIR/functions.sh"
    echo "appimgman will now exit."
    rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
    exit 0
fi

if [ "$EUID" = "0" ]; then # Prevent appimgman from being ran as root
    echo "Do not run appimgman as root!"
    exit 1
fi

if [ ! -f ~/.config/appimgman/cache/appimgman.lock ]; then # Create ~/.config/appimgman/cache/appimgman.lock file and prevent multiple instances by checking if it exists before running
    touch ~/.config/appimgman/cache/appimgman.lock
else
    echo "appimgman is currently running or did not exit properly; exiting..."
    exit 1
fi

rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before running just in case

if [ ! -d ~/.config/appimgman ]; then # Create dirs for configs if they don't exist
    echo "appimgman is being ran for the first time."
    echo "Creating config directories..."
    mkdir ~/.config/appimgman
    mkdir ~/.config/appimgman/installed
    mkdir ~/.config/appimgman/cache
    echo "Generating AppImages-bintray.lst from https://dl.bintray.com/probono/AppImages/ ..."
    wget --show-progress --quiet "https://dl.bintray.com/probono/AppImages/" -O - | sed 's/<\/*[^>]*>//g' | grep -o '.*AppImage' | cut -f1 -d"-" | sort -u > ~/.config/appimgman/AppImages-bintray.lst
    echo "Downloading AppImages-github.lst from appimgman github..."
    wget --quiet --show-progress "https://raw.githubusercontent.com/simoniz0r/appimgman/master/AppImages-github.lst"
    echo "First run operations complete!"
fi

case $1 in
    install|-i) # Check if app is already installed either by appimgman or otherwise then install app to /usr/local/bin if it is in known lists
        INSTIMG="$2"
        installstartfunc # Check for valid inputs and start gathering info for install
        appimgdlfunc "$INSTIMG" # Download AppImage from Bintray or Github
        appimginstallfunc # Install AppImage
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    update|-upd) # Update AppImage lists and check version from install info stored in ~/.config/appimgman/installed against latest url
        updatelistfunc "$@"
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    update-force|-updf) # Force specified AppImage to be upgraded by adding it to the upgrade-list.lst
        INSTIMG="$2"
        updateforcefunc # Force AppImage to be added to upgrade-list.lst regardless of version
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    upgrade|-upg) # upgrade AppImages to latest version if on upgrade-list.lst; update argument must be ran to put them on update-list.lst
        if [ ! -f ~/.config/appimgman/upgrade-list.lst ]; then
            echo "No upgrades available; try running 'appimgman update'." # If no AppImages in upgrade-list.lst, exit
            rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
            exit 0
        fi
        if [ -z "$2" ]; then # If no AppImage specified, upgrade all AppImages in upgrade-list.lst
            INSTIMG="$2"
            upgradestartallfunc # Run a for loop that checks each installed AppImage for upgrades
            rm -f ~/.config/appimgman/upgrade-list.lst # Remove upgrade-list.lst after upgrades finish
            rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
            exit 0
        elif grep -qw "$2" ~/.config/appimgman/upgrade-list.lst; then # If user specifies AppImage, upgrade that AppImage
            INSTIMG="$2"
            upgradestartfunc # Check specified AppImage for upgrade
        else # If upgrade-list.lst doesn't exist, suggest to run update function
            echo "No new upgrade for $2; try running 'appimgman update'."
            rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
            exit 0
        fi
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    remove|-r) # rm AppImage from /usr/local/bin and rm install info in ~/.config/appimgman/installed
        if [ -z "$2" ]; then # Exit if no AppImage input
            echo "AppImage input required; exiting..."
            rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        REMIMG="$2"
        echo "Current installed $REMIMG information:" # Output AppImage installed info if installed, exit if not
        if [ -f ~/.config/appimgman/installed/"$REMIMG" ]; then
            cat ~/.config/appimgman/installed/"$REMIMG"
        else
            echo "AppImage not found!"
            rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        appimgremovefunc # Run remove function for AppImage
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    list|-l) # List installed AppImages, AppImages-bintray.lst, and AppImages-github.lst or list info about specified AppImage
        LISTIMG="$2"
        if [ -z "$LISTIMG" ]; then # If no AppImage input, list all AppImages
            appimglistallfunc # List all installed and all available AppImages
        else # If AppImage input, list info for that AppImage
            appimglistfunc # List information about specified AppImage
        fi
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    list-installed|-li) # List information about installed AppImages
        appimglistinstalledfunc # List all installed AppImages and info
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    *) # Any unknown arguments go to help func
        helpfunc
        rm -rf ~/.config/appimgman/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
esac
