#!/bin/bash
# Title: spm
# Description: Downloads AppImages and moves them to /usr/local/bin/.  Can also upgrade and remove installed AppImages.
# Dependencies: GNU coreutils, tar, wget, python3.x
# Author: simonizor
# Website: http://www.simonizor.gq
# License: GPL v2.0 only

X="0.0.8"
# Set spm version
CONFDIR="$HOME/.config/spm"

if [ "$EUID" = "0" ]; then # Prevent spm from being ran as root
    echo "Do not run spm as root!"
    exit 1
fi

if [ -f ~/.config/simplepackagemanager/spm.conf ]; then
    . ~/.config/simplepackagemanager/spm.conf
elif [ -f ~/.config/spm/spm.conf ]; then
    . ~/.config/spm/spm.conf
fi

if [ ! -d "$CONFDIR" ]; then # Create dirs for configs if they don't exist
    echo "spm is being ran for the first time."
    echo "Creating config directories..."
    mkdir "$CONFDIR"
    case $? in
        1)
            echo "Failed to create $HOME/.config/spm; falling back to $HOME/.config/simplepackagemanager ..."
            CONFDIR="$HOME/.config/simplepackagemanager"
            mkdir "$CONFDIR" || { echo "Why are we still failing here? Something wrong with $HOME/.config ?"; exit 1; }
            ;;
    esac
    mkdir "$CONFDIR"/tarinstalled
    mkdir "$CONFDIR"/appimginstalled
    mkdir "$CONFDIR"/tarupgrades
    mkdir "$CONFDIR"/appimgupgrades
    mkdir "$CONFDIR"/cache
    echo "CONFDIR="\"$CONFDIR\""" > "$CONFDIR"/spm.conf
    # echo "Generating AppImages-bintray.lst from https://dl.bintray.com/probono/AppImages/ ..."
    # wget --show-progress --quiet "https://dl.bintray.com/probono/AppImages/" -O - | sed 's/<\/*[^>]*>//g' | grep -o '.*AppImage' | cut -f1 -d"-" | sort -u > "$CONFDIR"/AppImages-bintray.lst
    echo "Downloading AppImages-github.lst from spm github..."
    wget --quiet --show-progress "https://raw.githubusercontent.com/simoniz0r/spm/master/AppImages-github.lst" -O "$CONFDIR"/AppImages-github.lst
    echo "Downloading tar-pkgs.json from spm github repo..."
    wget --quiet --show-progress "https://raw.githubusercontent.com/simoniz0r/spm/master/tar-pkgs.json" -O "$CONFDIR"/tar-pkgs.json
    echo "First run operations complete!"
fi

REALPATH="$(readlink -f $0)"
RUNNING_DIR="$(dirname "$REALPATH")" # Find directory script is running from
if [ -f $RUNNING_DIR/spmfunctions.sh ]; then
    FUNCTIONS_VER="$(cat "$RUNNING_DIR"/spmfunctions.sh | sed -n 9p | cut -f2 -d'"')"
    if [ "$X" != "$FUNCTIONS_VER" ]; then
        echo "spmfunctions.sh $FUNCTIONS_VER version does not match $X; removing and updating..."
        rm "$RUNNING_DIR"/spmfunctions.sh || { echo "rm $RUNNING_DIR/spmfunctions.sh failed; trying with sudo..."; sudo rm "$RUNNING_DIR"/spmfunctions.sh; }
        echo "$RUNNING_DIR/spmfunctions.sh has been removed."
        echo "Downloading spmfunctions.sh from spm github repo..."
        wget --quiet --show-progress "https://github.com/simoniz0r/appimgman/raw/spm/spmfunctions.sh" -O "$CONFDIR"/cache/spmfunctions.sh
        chmod +x "$CONFDIR"/cache/spmfunctions.sh
        mv "$CONFDIR"/cache/spmfunctions.sh "$RUNNING_DIR"/spmfunctions.sh || { echo "mv to $RUNNING_DIR failed; trying as sudo..."; sudo mv "$CONFDIR"/cache/spmfunctions.sh "$RUNNING_DIR"/spmfunctions.sh; }
        echo "spmfunctions.sh saved to $RUNNING_DIR/spmfunctions.sh"
    fi
else
    echo "Missing required file $RUNNING_DIR/spmfunctions.sh !"
    echo "Downloading spmfunctions.sh from spm github repo..."
    wget --quiet --show-progress "https://github.com/simoniz0r/appimgman/raw/spm/spmfunctions.sh" -O "$CONFDIR"/cache/spmfunctions.sh
    chmod +x "$CONFDIR"/cache/spmfunctions.sh
    mv "$CONFDIR"/cache/spmfunctions.sh "$RUNNING_DIR"/spmfunctions.sh || { echo "mv to $RUNNING_DIR failed; trying as sudo..."; sudo mv "$CONFDIR"/cache/spmfunctions.sh "$RUNNING_DIR"/spmfunctions.sh; }
    echo "spmfunctions.sh saved to $RUNNING_DIR/spmfunctions.sh"
fi
source "$RUNNING_DIR"/spmfunctions.sh # import functions from spmfunctions.sh

spmdepchecksfunc || { echo "Could not load $RUNNING_DIR/spmfunctions.sh; exiting..."; exit 1; } # Check for deps, exit if not present

appimgfunctioncheckfunc # Check if appimgfunctions.sh exists, check version if it does, download if out of date or doesn't
source "$RUNNING_DIR"/appimgfunctions.sh # import functions from appimgfunctions.sh
appimgfunctionsexistsfunc  || { echo "Could not load $RUNNING_DIR/appimgfunctions.sh; exiting..."; exit 1; }

tarfunctioncheckfunc # Check if tarfunctions.sh exists, check version if it does, download if out of date or doesn't
source "$RUNNING_DIR"/tarfunctions.sh # import functions from tarfunctions.sh
tarfunctionsexistfunc || { echo "Could not load $RUNNING_DIR/tarfunctions.sh; exiting..."; exit 1; }

jsonparsecheck

spmlockfunc # Create "$CONFDIR"/cache/spm.lock file and prevent multiple instances by checking if it exists before running

case $1 in
    appimg-install|-ai) # Check if app is already installed either by spm or otherwise then install app to /usr/local/bin if it is in known lists
        if [ -z "$2" ]; then
            echo "Package input required; exiting..."
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        INSTIMG="$2"
        appimginstallstartfunc # Check for valid inputs and start gathering info for install
        appimgdlfunc "$INSTIMG" # Download AppImage from Bintray or Github
        appimginstallfunc # Install AppImage
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tarinstall|-ti) # Check if app is already installed either by spm or otherwise then install app to /usr/local/bin if it is in known lists
        if [ -z "$2" ]; then
            echo "Package input required; exiting..."
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        TARPKG="$2"
        tarinstallstartfunc
        tardlfunc "$TARPKG"
        tarcheckfunc
        tarinstallfunc
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tar-custom|-tc)
        if [ -z "$2" ]; then
            echo "Package input required; exiting..."
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        TARPKG="$2"
        tarcustomstartfunc
        tarcustomdlfunc "$TARPKG"
        tarcheckfunc
        tarcustominfofunc
        tarcustomappfunc
        rm -rf "$CONFDIR"/cache/*
        exit 0
        ;;
    update|-upd) # Update AppImage lists and check version from install info stored in "$CONFDIR"/installed against latest url
        spmvercheckfunc
        # Need to fix this so package input checks only go to relevant function
        if [ ! -z "$2" ]; then
            # if grep -qiw "$2" "$CONFDIR"/AppImages-bintray.lst ||grep -qiw "$2" "$CONFDIR"/AppImages-github.lst; then
            if grep -qiw "$2" "$CONFDIR"/AppImages-github.lst; then
                appimgupdatelistfunc "$2"
            elif [ -f "$CONFDIR"/tarinstalled/"$2" ]; then
                tarupdatelistfunc "$2"
            else
                echo "Package not found!"
                rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
                exit 1
            fi
        else
            appimgupdatelistfunc
            echo
            tarupdatelistfunc
        fi
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    appimg-update-force|-auf) # Force specified AppImage to be upgraded by adding it to the upgrade-list.lst
        INSTIMG="$2"
        appimgupdateforcefunc # Force AppImage to be added to upgrade-list.lst regardless of version
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tar-update-force|-tuf) # Force specified AppImage to be upgraded by adding it to the upgrade-list.lst
        TARPKG="$2"
        tarupdateforcefunc # Force AppImage to be added to upgrade-list.lst regardless of version
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    upgrade|-upg) # upgrade AppImages to latest version if on upgrade-list.lst; update argument must be ran to put them on update-list.lst
        if [ ! -f "$CONFDIR"/upgrade-list.lst ]; then
            echo "No AppImage upgrades; skipping AppImage upgrade function..."
            echo
            APPIMGUPGRADES="FALSE"
        else
            APPIMGUPGRADES="TRUE"
        fi
        if [ "$(dir "$CONFDIR"/tarupgrades | wc -l)" = "1" ]; then
            TARUPGRADES="TRUE"
            echo "$(tput setaf 2)$(dir -C -w 1 "$CONFDIR"/tarupgrades | wc -l) new tar package upgrade available.$(tput sgr0)"
        elif [ "$(dir "$CONFDIR"/tarupgrades | wc -l)" = "0" ]; then
            echo "No tar package upgrades; skipping tar upgrade function..."
            echo
            TARUPGRADES="FALSE"
            if [ "$APPIMGUPGRADES" = "FALSE" ]; then
                echo "No new upgrades available; try running 'spm update'."
                rm -rf "$CONFDIR"/cache/*
                exit 0
            fi
        else
            echo "$(tput setaf 2)$(dir -C -w 1 "$CONFDIR"/tarupgrades | wc -l) new upgrades available.$(tput sgr0)"
            TARUPGRADES="TRUE"
        fi
        if [ -z "$2" ]; then # If no AppImage specified, upgrade all AppImages in upgrade-list.lst
            if [ "$APPIMGUPGRADES" = "TRUE" ]; then
                appimgupgradestartallfunc # Run a for loop that checks each installed AppImage for upgrades
            fi
            echo
            if [ "$TARUPGRADES" = "TRUE" ]; then
                tarupgradestartallfunc
            fi
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 0
        elif [ "$TARUPGRADES" = "TRUE" ] || [ "$APPIMGUPGRADES" = "TRUE" ]; then # If user specifies package, upgrade that package
            INSTIMG="$2"
            if [ "$APPIMGUPGRADES" = "TRUE" ]; then
                appimgupgradestartfunc # Check specified AppImage for upgrade
            fi
            echo
            if [ "$TARUPGRADES" = "TRUE" ]; then
                tarupgradestartfunc
            fi
        else # If upgrade-list.lst doesn't exist, suggest to run update function
            echo "No new upgrade for $2; try running 'spm update'."
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 0
        fi
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    appimg-remove|-ar) # rm AppImage from /usr/local/bin and rm install info in "$CONFDIR"/installed
        if [ -z "$2" ]; then # Exit if no AppImage input
            echo "AppImage input required; exiting..."
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        REMIMG="$2"
        echo "Current installed $REMIMG information:" # Output AppImage installed info if installed, exit if not
        if [ -f "$CONFDIR"/appimginstalled/"$REMIMG" ]; then
            cat "$CONFDIR"/appimginstalled/"$REMIMG"
        else
            echo "AppImage not found!"
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        appimgremovefunc # Run remove function for AppImage
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tar-remove|-tr) # Remove: remove pkg while leaving pkg's config files
        if [ -z "$2" ]; then
            echo "Package input required; exiting..."
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        REMPKG="$2"
        echo "Current installed $REMPKG information:"
        if [ -f "$CONFDIR"/tarinstalled/"$REMPKG" ]; then
            cat "$CONFDIR"/tarinstalled/"$REMPKG"
        else
            echo "Package not found!"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        tarappcheckfunc "$REMPKG"
        tarremovefunc
        rm -rf "$CONFDIR"/cache/*
        exit 0
        ;;
    tar-remove-purge|-trp) # Remove Purge: remove pkg and also remove pkg's config files
        if [ -z "$2" ]; then
            echo "Package input required; exiting..."
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        PURGEPKG="$2"
        echo "Current installed $PURGEPKG information:"
        if [ -f "$CONFDIR"/tarinstalled/"$PURGEPKG" ]; then
            cat "$CONFDIR"/tarinstalled/"$PURGEPKG"
        else
            echo "Package not found!"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        tarappcheckfunc "$PURGEPKG"
        tarremovepurgefunc
        rm -rf "$CONFDIR"/cache/*
        exit 0
        ;;
    list|-l) # List installed AppImages, AppImages-bintray.lst, and AppImages-github.lst or list info about specified AppImage
        # Need to fix this so package input checks only go to relevant function
        LISTIMG="$2"
        LISTPKG="$2"
        if [ -z "$LISTIMG" ]; then # If no AppImage input, list all AppImages
            echo "AppImages:"
            appimglistallfunc # List all installed and all available AppImages
            echo
            echo "tar packages:"
            tarlistfunc
        else # If AppImage input, list info for that AppImage
            if grep -q "$LISTIMG" "$CONFDIR"/AppImages-github.lst; then
                appimglistfunc # List information about specified AppImage
                ISAPPIMG="TRUE"
            fi
            if echo "$TAR_LIST" | grep -qiw "$LISTPKG"; then
                tarlistfunc
                ISTAR="TRUE"
            fi
            if [ -z "$ISAPPIMG" ] && [ -z "$ISTAR" ]; then
                echo "$2 not found!"
                rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
                exit 1
            fi
        fi
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    list-installed|-li) # List information about installed AppImages
        echo "AppImages:"
        appimglistinstalledfunc # List all installed AppImages and info
        echo
        echo "tar packages:"
        tarlistinstalledfunc
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    *) # Any unknown arguments go to help func
        helpfunc
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
esac
