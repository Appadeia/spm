#!/bin/bash -e
# Title: spm
# Description: Downloads and installs AppImages and precompiled tar archives.  Can also upgrade and remove installed packages.
# Dependencies: GNU coreutils, tar, wget
# Author: simonizor
# Website: http://www.simonizor.gq
# License: GPL v2.0 only

X="0.5.4"
# Set spm version
CONFDIR="$HOME/.config/spm"
SKIP_DEP_CHECKS="FALSE"

if [ "$EUID" = "0" ]; then # Prevent spm from being ran as root
    echo "Do not run spm as root!"
    exit 1
fi

if [ -f ~/.config/spm/spm.conf ]; then
    . ~/.config/spm/spm.conf
fi

if [ ! -d "$CONFDIR" ]; then # Create dirs for configs, config files, and download package lists if they don't exist
    echo "spm is being ran for the first time."
    echo "Creating config directories..."
    mkdir "$CONFDIR"
    mkdir "$CONFDIR"/tarinstalled
    mkdir "$CONFDIR"/appimginstalled
    mkdir "$CONFDIR"/tarupgrades
    mkdir "$CONFDIR"/appimgupgrades
    mkdir "$CONFDIR"/cache
    echo "CONFDIR="\"$CONFDIR\""" > "$CONFDIR"/spm.conf
    echo "GITHUB_TOKEN="\"\""" >> "$CONFDIR"/spm.conf
    echo "SKIP_DEP_CHECKS="\"FALSE\""" >> "$CONFDIR"/spm.conf
    echo "First run operations complete!"
fi

if [ ! -f "$CONFDIR/AppImages.yml" ]; then
    echo "Downloading AppImages.yml from spm github..."
    wget --quiet "https://raw.githubusercontent.com/simoniz0r/spm-repo/master/AppImages.yml" -O "$CONFDIR"/AppImages.yml
    echo "Downloading tar-pkgs.yml from spm github repo..."
    wget --quiet "https://raw.githubusercontent.com/simoniz0r/spm-repo/master/tar-pkgs.yml" -O "$CONFDIR"/tar-pkgs.yml
fi

REALPATH="$(readlink -f $0)"
RUNNING_DIR="$(dirname "$REALPATH")" # Find directory script is running from
if [ -f $RUNNING_DIR/spmfunctions.sh ]; then # Check to make sure spmfunctions.sh exists and is up to date
    FUNCTIONS_VER="$(cat "$RUNNING_DIR"/spmfunctions.sh | sed -n 9p | cut -f2 -d'"')"
    if [ "$X" != "$FUNCTIONS_VER" ]; then
        echo "$$(tput setaf 1)spmfunctions.sh $FUNCTIONS_VER version does not match $X !"
        echo "spmfunctions.sh is out of date! Please download the full release of spm from https://github.com/simoniz0r/spm/releases !$(tput sgr0)"
        exit 1
    fi
else
    echo "$(tput setaf 1)Missing required file $RUNNING_DIR/spmfunctions.sh !"
        echo "spmfunctions.sh is missing! Please download the full release of spm from https://github.com/simoniz0r/spm/releases !$(tput sgr0)"
        exit 1
fi
source "$RUNNING_DIR"/spmfunctions.sh # import functions from spmfunctions.sh

spmdepchecksfunc || { echo "$(tput setaf 1)Could not load $RUNNING_DIR/spmfunctions.sh; exiting...$(tput sgr0)"; exit 1; } # Check for deps, exit if not present

if type spm >/dev/null 2>&1 && [ -f ~/.zshrc ] && ! grep -q 'spm.comp' ~/.zshrc; then # If using zsh and spm is installed, add tab completions for spm
    wget --quiet "https://raw.githubusercontent.com/simoniz0r/spm/master/spm.comp" -O "$CONFDIR"/spm.comp
    echo "" >> ~/.zshrc
    echo "if [ -f "$CONFDIR"/spm.comp ]; then" >> ~/.zshrc
    echo "    source "$CONFDIR"/spm.comp" >> ~/.zshrc
    echo "    compdef _spm spm" >> ~/.zshrc
    echo "fi" >> ~/.zshrc
    echo "" >> ~/.zshrc
fi

appimgfunctioncheckfunc # Check to make sure appimgfunctions.sh exists and is up to date
source "$RUNNING_DIR"/appimgfunctions.sh # import functions from appimgfunctions.sh
appimgfunctionsexistsfunc  || { echo "$(tput setaf 1)Could not load $RUNNING_DIR/appimgfunctions.sh; exiting...$(tput sgr0)"; exit 1; }

tarfunctioncheckfunc # Check to make sure tarfunctions.sh exists and is up to date
source "$RUNNING_DIR"/tarfunctions.sh # import functions from tarfunctions.sh
tarfunctionsexistfunc || { echo "$(tput setaf 1)Could not load $RUNNING_DIR/tarfunctions.sh; exiting...$(tput sgr0)"; exit 1; }

spmlockfunc # Create "$CONFDIR"/cache/spm.lock file and prevent multiple instances by checking if it exists before running

if [ -z "$GITHUB_TOKEN" ]; then # Display github rate limit by using wget to show https://api.github.com/rate_limit
    wget -S --spider "https://api.github.com/rate_limit" -o "$CONFDIR"/cache/rate.limit
    echo "Github API rate limit: $(grep -m 1 '.*X-RateLimit-Remaining:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" ")/60 until $(date -d@$(grep -m 1 '.*X-RateLimit-Reset:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" ") +"%T, %F")."
else
    wget -S --spider --quiet --auth-no-challenge --header="Authorization: token "$GITHUB_TOKEN"" "https://api.github.com/rate_limit" -o "$CONFDIR"/cache/rate.limit
    echo "Github API rate limit : $(grep -m 1 '.*X-RateLimit-Remaining:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" ")/5000 until $(date -d@$(grep -m 1 '.*X-RateLimit-Reset:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" ") +"%T, %F")."
fi
if [ "$(grep -m 1 '.*X-RateLimit-Remaining:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" ")" = "0" ]; then # Attempt to exit to prevent errors if user's github rate limit has been used up
    echo "$(tput setaf 1)Github API rate limit reached! Try again at $(date -d@$(grep -m 1 '.*X-RateLimit-Reset:*.' "$CONFDIR"/cache/rate.limit | cut -f4 -d" "))."
    echo "If you haven't already, you can add your token to $CONFDIR/spm.conf"
    echo "to avoid hitting the rate limit.$(tput sgr0)"
    rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
    exit 1
fi
echo

case $1 in
    appimg-install|-ai) # Check if package is already installed either by spm or otherwise then install package
        if [ -z "$2" ]; then
            echo "$(tput setaf 1)Package input required; exiting...$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        INSTIMG="$2"
        appimginstallstartfunc # Check if specified AppImage is in list, get info for it
        appimgdlfunc "$INSTIMG" # Download AppImage using info from above
        appimginstallfunc # Move downloaded AppImage from $CONFDIR/cache to /usr/local/bin and save config file for spm to keep track of it
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tarinstall|-ti) # Check if package is already installed either by spm or otherwise then install package
        if [ -z "$2" ]; then
            echo "$(tput setaf 1)Package input required; exiting...$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        TARPKG="$2"
        tarinstallstartfunc # Check if specified tar package is in list, get info for it
        tardlfunc "$TARPKG" # Download tar package using info from above
        tarcheckfunc # Check to make sure file downloaded is a tar and run relevant tar arguments for file type
        tarinstallfunc # Move extracted tar from $CONFDIR/cache to /opt/PackageName, create symlinks for .desktop and bin file, and save config file for spm to keep track of it
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    update|-upd) # Update package lists and check for package upgrades
        spmvercheckfunc # Check spm version and let user know if it is out of date
        updatestartfunc "$2" # Send input to relevant update function or run both if no input
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    appimg-update-force|-auf) # Force AppImage to be marked for upgrade
        INSTIMG="$2"
        appimgupdateforcefunc # Place a file containing AppImage info in $CONFDIR/appimgupgrades/PackageName for upgrade function to get info from without checking version
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tar-update-force|-tuf) # Force tar package to be marked for upgrade
        TARPKG="$2"
        tarupdateforcefunc # Place a file containing tar package info in $CONFDIR/tarupgrades/PackageName for upgrade function to get info from without checking version
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    upgrade|-upg) # upgrade packages to latest version if marked for upgrade
        upgradestartfunc "$2" # Check which (if any) package types have upgrades and run relevant functions
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    appimg-remove|-ar) # rm AppImage from /usr/local/bin and rm install info in "$CONFDIR"/installed
        if [ -z "$2" ]; then
            echo "$(tput setaf 1)AppImage input required; exiting...$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        REMIMG="$2"
        if [ -f "$CONFDIR"/appimginstalled/"$REMIMG" ]; then # Output info about AppImage before removing, exit if not installed
            echo "$(tput bold)$(tput setaf 2)Current installed $REMIMG information$(tput sgr0):"
            . "$CONFDIR"/appimginstalled/"$REMIMG"
            echo "$(tput bold)$(tput setaf 2)Info$(tput sgr0):  $APPIMAGE_DESCRIPTION"
            if [ -z "$APPIMAGE_NAME" ]; then
                echo "$(tput bold)$(tput setaf 2)Name$(tput sgr0):  $APPIMAGE"
            else
                echo "$(tput bold)$(tput setaf 2)Name$(tput sgr0):  $APPIMAGE_NAME"
            fi
            echo "$(tput bold)$(tput setaf 2)Version$(tput sgr0):  $APPIMAGE_VERSION"
            echo "$(tput bold)$(tput setaf 2)URL$(tput sgr0):  $WEBSITE"
            echo "$(tput bold)$(tput setaf 2)Install dir$(tput sgr0): $BIN_PATH"
            echo
            else
            echo "$(tput setaf 1)AppImage not found!$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
            exit 1
        fi
        appimgremovefunc # Remove AppImage from /usr/local/bin and remove conf file in $CONFDIR/appimginstalled/PackageName
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    tar-remove|-tr) # Remove: remove pkg while leaving pkg's config files
        if [ -z "$2" ]; then
            echo "$(tput setaf 1)Package input required; exiting...$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        REMPKG="$2"
        if [ -f "$CONFDIR"/tarinstalled/"$REMPKG" ]; then # Output info about tar package before removing, exit if not installed
            echo "$(tput bold)$(tput setaf 6)Current installed $REMPKG information$(tput sgr0):"
            . "$CONFDIR"/tarinstalled/"$REMPKG"
            echo "$(tput bold)$(tput setaf 6)Info$(tput sgr0):  $TAR_DESCRIPTION"
            echo "$(tput bold)$(tput setaf 6)Deps$(tput sgr0):  $DEPENDENCIES"
            if [ -z "$TAR_GITHUB_COMMIT" ]; then
                echo "$(tput bold)$(tput setaf 6)Version$(tput sgr0):  $TARFILE"
            else
                echo "$(tput bold)$(tput setaf 6)Version$(tput sgr0):  $TAR_GITHUB_COMMIT"
            fi
            echo "$(tput bold)$(tput setaf 6)Source$(tput sgr0):  $TAR_DOWNLOAD_SOURCE"
            echo "$(tput bold)$(tput setaf 6)URL$(tput sgr0):  $TARURI"
            echo "$(tput bold)$(tput setaf 6)Install dir$(tput sgr0):  $INSTDIR"
            echo "$(tput bold)$(tput setaf 6)Bin path$(tput sgr0):  $BIN_PATH"
            echo
        else
            echo "$(tput setaf 1)Package not found!$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        TARPKG="$REMPKG"
        tarappcheckfunc # Load info about tar package using this function so tarremovefunc knows where it is
        tarremovefunc # Use info from above to remove /opt/PackageName and symlinks for .desktop and bin file
        rm -rf "$CONFDIR"/cache/*
        exit 0
        ;;
    tar-remove-purge|-trp) # Remove Purge: remove pkg and also remove pkg's config files
        if [ -z "$2" ]; then
            echo "$(tput setaf 1)Package input required; exiting...$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        PURGEPKG="$2"
        if [ -f "$CONFDIR"/tarinstalled/"$PURGEPKG" ]; then # Show info about package before purging, exit if not installed
            echo "$(tput bold)$(tput setaf 6)Current installed $PURGEPKG information$(tput sgr0):"
            . "$CONFDIR"/tarinstalled/"$PURGEPKG"
            echo "$(tput bold)$(tput setaf 6)Info$(tput sgr0):  $TAR_DESCRIPTION"
            echo "$(tput bold)$(tput setaf 6)Deps$(tput sgr0):  $DEPENDENCIES"
            if [ -z "$TAR_GITHUB_COMMIT" ]; then
                echo "$(tput bold)$(tput setaf 6)Version$(tput sgr0):  $TARFILE"
            else
                echo "$(tput bold)$(tput setaf 6)Version$(tput sgr0):  $TAR_GITHUB_COMMIT"
            fi
            echo "$(tput bold)$(tput setaf 6)Source$(tput sgr0):  $TAR_DOWNLOAD_SOURCE"
            echo "$(tput bold)$(tput setaf 6)URL$(tput sgr0):  $TARURI"
            echo "$(tput bold)$(tput setaf 6)Install dir$(tput sgr0):  $INSTDIR"
            echo "$(tput bold)$(tput setaf 6)Bin path$(tput sgr0):  $BIN_PATH"
            echo
        else
            echo "$(tput setaf 1)Package not found!$(tput sgr0)"
            rm -rf "$CONFDIR"/cache/*
            exit 1
        fi
        TARPKG="$REMPKG"
        tarappcheckfunc # Load info about tar package using this function so tarremovefunc knows where it is
        tarremovepurgefunc # Use info from above to remove /opt/PackageName, config dir if listed in tar-pkgs.json, and symlinks for .desktop and bin file
        rm -rf "$CONFDIR"/cache/*
        exit 0
        ;;
    list|-l) # List installed packages or info about specified package
        INSTIMG="$2"
        TARPKG="$2"
        liststartfunc # Send package input to relevant list function or run both if no input
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    list-installed|-li) # List information about installed packages
        echo "$(tput bold)$(tput setaf 2)AppImages$(tput sgr0):"
        echo
        appimglistinstalledfunc # List info about all installed AppImages
        echo
        echo "$(tput bold)$(tput setaf 6)tar packages$(tput sgr0):"
        echo
        tarlistinstalledfunc # List info about all installed tar packages
        echo "$(tput bold)$(tput setaf 2)$(dir -C -w 1 "$CONFDIR"/appimginstalled | wc -l) AppImages installed$(tput sgr0):" # Output number of and names of installed AppImages
        dir -C -w 1 "$CONFDIR"/appimginstalled | pr -tT --column=3 -w 125
        echo
        echo "$(tput bold)$(tput setaf 6)$(dir -C -w 1 "$CONFDIR"/tarinstalled | wc -l) tar packages installed$(tput sgr0):" # Output number of and names of installed tar packages
        dir -C -w 1 "$CONFDIR"/tarinstalled | pr -tT --column=3 -w 125
        echo
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    search|-s) # Use grep to search package lists based on user input and output matching packages and which list they are in
        if cat "$CONFDIR"/AppImages.yml | cut -f1 -d":" | grep -q "$2"; then
            echo "$(tput bold)$(tput setaf 2)AppImage(s)$(tput sgr0):"
            cat "$CONFDIR"/AppImages.yml | cut -f1 -d":" | grep "$2"
            echo
        fi
        if echo "$TAR_LIST" | grep -q "$2"; then
            echo "$(tput bold)$(tput setaf 6)tar package(s)$(tput sgr0):"
            echo "$TAR_LIST" | grep "$2"
            echo
        fi
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    man|-m) # run man $RUNNING_DIR/spm.1 to show spm's man file
        man $RUNNING_DIR/spm.1
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
    *) # Any unknown arguments go to help func
        helpfunc
        rm -rf "$CONFDIR"/cache/* # Remove any files in cache before exiting
        exit 0
        ;;
esac
